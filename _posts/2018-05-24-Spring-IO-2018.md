---
layout: post
authors: [dieter_hubau, yannick_de_turck]
title: 'Spring IO 2018'
image: /img/spring-io-2018/spring-io.jpg
tags: [Spring IO,Spring,Java,Conference]
category: Conference
comments: true
---

## Spring IO is back!

TODO: Intro

> TODO: describe venue

****

<img class="image fit" src="{{ '/img/spring-io-2018/springio.jpg' | prepend: site.baseurl }}" alt="Spring IO 2018 Photo Collage" />

****

## Day 1: Talks

* [Mark Heckler: Migrating legacy enterprise Java applications to Spring Boot](#mark-heckler-migrating-legacy-enterprise-java-applications-to-spring-boot)
* [Andreas Falker: Spring Security 5 Workshop](#andreas-falker-spring-security-5-workshop)
* [Tommy Ludwig: Observability with Spring based distributed systems](#tommy-ludwig-observability-with-spring-based-distributed-systems)

****

## Mark Heckler: Migrating legacy enterprise Java applications to Spring Boot

You can find him on Twitter at [@mkheckler](https://twitter.com/mkheckler).

- Write schema.sql and data.sql commands to migrate and test database
- Generate skeleton project from start.spring.io
- Use Kotlin to vastly simplify your code
  - data classes to simplify access to members and constructors
  - put constructor definition in the same line as the class definition
- Using Spring Data, no more need to use PersistenceContext or EntityManager
- Using Spring MVC with `@RestController`, no more need to declare `@Produces` or `@Consumes`

### Benefits

- Less code
- Less boilerplate
- Better maintainable code
- Better/more deployment options

## Andreas Falker: Spring Security 5 Workshop

https://andifalk.github.io/spring-security-5-workshop/

## Oliver Gierke: REST beyond the obvious - API design for ever evolving systems

## Jurgen Hoeller: Spring Framework 5 - Hidden Gems

Since almost every feature was backported to 4.3, most of them are already known to the general public.
Though there are 7 areas of refinement within 5.0 that aren’t widely known to the public.

### Commons Logging Bridge

So the Spring team came up with a new dependency called spring-jcl which is actually a reimplementation of a logging bridge.
It is a required dependency and is here to help streamline the logging functionality.
The main difference with this way of working is that you don’t need to go through a dependency hell where you would manually add exclusions to ignore certain logging dependencies.
Just add the logging library to your classpath and everything will switch to the logging implementation of your choice.
It now has first class support for Log4J 2 (version 1 has reached its end of life), SLF4J and JUL.

### Build-Time Components Indexer

The file system traversal for classpath scanning of all packages within the specified base packages using either `<context:component-scan>` or `@ComponentScan` might be slow on startup.
This is especially true if your application is started for a small period of time or where I/O is very expensive.
Think short-running batch processes and functions, or applications being started and stopped on Google App Engine every 2 minutes.
The common solution was to narrow your base packages, or even to fully enumerate your component classes so you would skip scanning all together.
Starting with 5.0 there is a new build-time annotation processor that will generate a META-INF/spring.components file per jar containing all the classes which in turn will be used automatically at runtime for compatible component-scan declarations.

### Nullability

The new version contains comprehensive nullability declarations across the codebase.
Fields, method parameters and method return values are still by default non-null, but now there are individual `@Nullable` declarations for actually nullable return values for example.
For Java this means that we have nullability validation in IntelliJ IDEA and Eclipse.
This allows the Spring Team to find subtle bugs or gaps within the framework's codebase.
It will also allow us as developers to validate our interactions with the Spring APIs.
When you're writing code in Kotlin it will give you straightforward assignments to non-null variables because the Kotlin compiler will only allow assignments for APIs with clear nullability.

### Data Class Binding

Spring Data can now work with immutable classes.
No need for setters anymore since it can work with named constructor arguments!
The property names are matched against the constructor parameter names.
You can do this by explicitly using `@ConstructorProperties`, or they are simply inferred from the class bytecode (if you pass `-parameters` or `-debug` as compilation argument).
This is a perfect match with Kotlin and Lombok data classes where the getter and setters are generated at compile time.

### Programmatic Lookup via ObjectProvider

The `ObjectProvider` is a variant of `ObjectFactory`, which is designed specifically for injection points, allowing for programmatic optionality and lenient not-unique handling.
This class had the following original methods: `@Nullable getIfAvailable()` and `@Nullable getIfUnique()`.
With the new version of Spring these methods have been overloaded with `java.util.function` callbacks which empowers the developer to return a default value instead of returning `null`.

### Refined Resource Interaction

Spring's `Resource` abstraction in core.io has been overhauled to expose the NIO.2 API at application level, eg. `Resource.getReadableChannel()` or `WritableResource.getWritableChannel()`.
They are also using the NIO.2 API internally wherever possible, eg. `FileSystemResource.getInput/OutputStream()` or `FileCopyUtils.copy(File, File)`.

### Asynchronous Execution

Spring 5.0 comes with a couple of interface changes that will help you with asynchrous execution:
- The `ListenableFuture` now has a `completable()` method which exposes the instance as a JDK `CompletableFuture`.
- The `TaskScheduler` interface has new methods as an alternative to `Date` and `long` arguments: `scheduleAtFixedRate(Runnable, Instant, Duration)` and `scheduleWithFixedDelay(Runnable, Instant, Duration)`.
- The new `ScheduledTaskHolder` interface for monitoring the current tasks, eg. `ScheduledTaskRegistrar.getScheduledTasks()` and `ScheduledAnnotationBeanPostProcessor.getScheduledTasks()`.

## Ray Tsang: Cloud Native with Google Cloud Platform and Spring Boot

Twitter: `@saturnism`
Google+: `+RayTsang`

- bit.ly/spring-gcp-lab

- Google PubSub:
  - Spring Integration works
  - Spring Cloud Stream binder implementation is coming
  - PubSub messages will be delivered at least once, so it can be processed multiple times by different workers
  - Unprocessed PubSub messages are only kept for 7 days

https://github.com/saturnism/spring-petclinic-gcp

## Breaking down monoliths into system of systems - Oliver Gierke

monolith -> microlith

monolith -> modulith -> system of systems (using messages, REST)

https://github.com/olivergierke/sos

- design patterns and strategies
- in the monolith:
  - reflect bounded contexts in the packages of your app
  - inter-context interaction is process local (easy so tempting to keep doing)
  - domain classes reference each other across bounded contexts
  - order context calls inventory context directly
  - services become centers of gravity
  - it is easy to refactor
  - strong consistency across bounded contexts (eg. thanks to transactions)
  - order mgmt becomes central hub across all contexts
- microlith: splitting up the system into smaller systems:
  - you need HTTP calls to update each other
  - unsafe, not foolproof, not easily repeatable, more error scenarios
  - marshalling / unmarshalling, networking, ...
  - add more technology to solve issues: bulkheads, retries, circuit breaker, asynchronous calls, scatter gather, ...
  - simple, local consistency is gone
  - local method invocation is transformed into RPC-ish HTTP call
  - all systems need to know all other invoked systems -> more technology (Eureka, config, ...)
  - strong focus on API contracts (REST docs, cruddy APIs, lack of hypermedia, breaking API changes)
- modulith (restructuring your monolith):
  - let your bounded contexts fire events
  - invert the dependency between bounded contexts (dont do method invocation on other contexts, send out events)
  - you can use Spring Core ApplicationEvent or Spring Data DomainEvents with `@EventListener`
  - differences with monolith:
    - focus of domain logic has moved to aggregate
    - integration between bounded contexts is event based
    - inverted dependency between bounded contexts
- system of systems:
  - integration options: messaging or REST
  - events are published as messages in a central message broker (Kafka, RabbitMQ)
    - this is shared infrastructure
    - needs to be built for scale
    - knows everything about all the systems
    - just like with REST, you are coupled via message serialization format
    - PRO TIP: `@JsonPath("$.product.id")` annotation for message payload
  - when using REST only (to avoid central message broker):
    - publish local events in your local API
    - client of that API polls the API for changes in events (using offsets or timestamps)
    - we consider events as part of the state of the system (HTTP resources for events)
    - collections of events should be filterable by: event type, publication time, pagination, caching, ...
    - media types: JSON, HAL, Atom Feeds even (XML)
    - the client is totally under control of the size of the consistency gap (they decide how frequently they poll)
    - events from a given bounded context stays locally in that context
    - disadvantages: bigger concistency gap, doesnt scale as good
    - testability becomes much easier, easily debuggable
  - so discussion becomes question of distributed system vs decentralized system
- bounded contexts interaction
- what kind of consistency do we require
- how do apps behave in error situations
- how can apps evolve independently

## Tommy Ludwig: Observability with Spring based distributed systems

<span class="image left"><img class="p-image" alt="Tommy Ludwig" src="/img/spring-io-2018/tommy-ludwig.jpg"></span>

### Introduction

[Tommy](https://twitter.com/tommyludwig){:target="blank"}'s talk introduced three main pillars of observability: logging, metrics, and tracing.

Tommy explained that observability is achieved through a set of tools and practices that aim to turn data points and contexts into insights.
Observability is something you should care about as it provides a great experience for the users of your system and it builds confidence in production where failure **will** happen.
You ought to give yourself the tools you need in order to be a good owner in order to detect this failures as early as possible.
Mean time to recovery is key here.
He also quoted Werner Vogels's, the CEO of Amazon, "You build it, you run it" while also adding to it that you need to monitor it.

Within a Spring Boot project, we have access to Actuator and it is awesome.
It comes with a lot of goodies out of the box.
There is also [Spring Boot Admin](https://github.com/codecentric/spring-boot-admin){:target="_blank"} that makes it easy to access and use each instance's Actuator endpoints.

Distributed systems make observing them hard by design as a request spans multiple processes.
You therefore need to stitch these together in order to fully make sense of it.
There are also more points of failure and adding multiple instances of the same service, for scaling reasons, will only increase the monitoring complexity.

Tommy named three sides to observability:
* Logging
* Metrics
* Tracing

### Logging
Logs are request scoped, arbitrary messages that you want to find back later.
They are formatted to give you context via things such as logging levels and the timestamp.
The issue with logs is that they do not scale, concurrent requests intermingle logs, and searching through them can be cumbersome.
In order to tackle these issues you can make use of centralized logging while also adding a query capability to retrieve a collection of matching logs.
Within Spring Boot we can configure the logging via Spring Environment and via Actuator at runtime.
[Spring Cloud Sleuth](https://cloud.spring.io/spring-cloud-sleuth/){:target="_blank"} is useful to add a trace ID for request correlation.

### Metrics
Metrics aggregate time series data and have a bounded size.
You can slice these based on dimensions, tags and labels.
The main goal of metrics is to visualize and identify trends and deviations, and to raise alerts based on metric queries.
Some examples of metrics are: response time, the response's body size and memory consumed.
In order to properly measure all this, you need to set up a metrics backend to which all applications publish their metrics data.
In Spring Boot 2, [Micrometer](https://github.com/micrometer-metrics/micrometer){:target="_blank"} is introduced as its native metrics library.
Micrometer supports many metrics backends such as Atlas Datadog, Prometheus, SignalFX and Wavefront.
A lot of the instrumentation is auto-configured by Spring Boot and custom metrics are easy to add.
These are configurable via properties and common tags such as the application name, the instance, region, zone, and more.

### Tracing
Local tracing happens via the Actuator `/httptrace` endpoint and displays the latency data.
With distributed tracing you can go across process boundaries which is useful as metrics lack request context and as logs have a local context but limited distributed info.
You define the sample of how many request to trace yourself as you don't want to trace everything especially if you have a high load.
[Zipkin](https://zipkin.io){:target="_blank"} with its UI helps you to see the timing information visually and is a good tracing backend for Spring applications.
Using Spring Cloud Sleuth, it auto-configured the tracing instrumentation via [Zipkin's Brave](https://github.com/openzipkin/brave){:target="_blank"}.
Via properties you can configure things such as the sampling probability and whether certain endpoints should to be skipped.

### Correlation everywhere
Having set up all of these, you now have correlated logging, metrics and tracing across your system, and you can find the data from each based on identifiers.

### Observability cycle
If an issue produces itself we can take the following steps to troubleshoot and bandage the situation:
* The issue should've been reported via an alert or report
* We check the metrics of our system
* If needed, we check the tracing data
* If needed, we check the logs
* Based on the gathered information we can triage the issue and make adjustments to prevent a recurrence

### Key takeaways
System wide observability is crucial in distributed architectures.
The tools to help you with this exist and Spring makes it easy to integrate them in your system as the most common cases are covered out-of-the-box or easily configurable.
Use the right tool for the job and synergise across the different tools.


## Got triggered?

All talks were recorded by the Spring IO team. You can view them [here](https://www.youtube.com/). TODO Add correct URL

****
