---
layout: post
authors: [pieter_vincken]
title: 'Istio Service Mesh'
image: /img/2019-04-01-istio-service-mesh/istio.jpeg
tags: [Istio, Service Mesh, Kubernetes, Cloud]
category: Cloud
comments: true
---

> This post will describe how to use the Istio service mesh to provide service to service authentication and authorization in a Kubernetes cluster.
> It will show how ServiceRoles, ServiceRoleBindings and Identities in Istio can be used to achieve this. 

# Table of content 

## What is Istio?

Istio is a service mesh created by Google, Lyft and IBM. 
It aims to simplify some security and management aspects of a microservices software architecture.
More information on Istio and it's feature can be found in it's [docs](https://istio.io/docs/).
In this blogpost we will highlight one of the key security features of Istio: service to service authentication and authorization.
For the sake of simplicity, this post will focus on an Istio setup in Kubernetes.

In a microservices architecture managing access to services can be a challenging operation. 
For end-user facing services, JWTs are often used to authenicate a request.
This token can be generated by an identify provider and a client can provide it as means to make itself known to a service.
For users, these tokens can be generated based on information that the end-user provides. 
In most cases this information is a username and password, with some additional 2FA if possible.

When authenticating services, providing an identiy is a bit harder.
One option is to use the same credential flow as end-users for services as well. 
A service would provide a username and password and receive a (temporarily valid) token to access a service.
Unfortunaly this approach has some drawbacks.
The first main issue is that services often need more broader access to services than end-users.
This makes the credentials they hold, very powerfull, which makes them dangerous to manage. 
Secondly, the JWT is only valid of predefined amount of time. 
For a normal user, this is fine, since they can easily reauthenticate once the token expires.
In services, reauthentication mechanisms tend to be a bit harder to setup and often result in hard to debug issues. 

Introducting service to service authentication through mutual trusted certificates. 
This approach uses public certificate and private key pairs to generate trust between services.
When a service is started, a service specific certificate is generated and provided to the service.
The service exposes this certificate and connecting services (clients) can validate it.
Because certificates can have a longer life span, this is easier to manage, compared to the JWT setup. 
Setting up certificates, adopting the services to use them and rotating them over time, can be very challenging.
Every services needs to expose a secure endpoint and serve the correct certificate.
This is a non-trivial step and can, again, introduce very hard to debug issues.

This is exactly where Istio pop up in the game.
It makes using certificates for service to service encryption and authentication easy.
Especially when using the automatic proxy injection, it's almost as easy as flipping a switch.

There are three main components responsible for making this possible: Citadel, Pilot and Mixer. 

Citadel is Istios fortress of trust.
It manages all certificates and acts as a Root CA in the Istio setup.

Pilot is the main information manager.
It is responsible for gathering all required information and communicating this to the sidecar proxies.
Pilot will initialise the proxies during start-up with their configuration and the certificates from Citadel.

Mixer is responsible for all monitoring, logging and authorization information.
Whenever a proxy performs an action, Mixer knows about it. 
This allows it to both monitor and log connections, but also provide authorization information to the proxies. 

A final, optional component is the sidecar injector.
This component is not mandatory for the service mesh to work, but makes using it a lot easier.
The injector is setup as a mutating webhook admission controller. 
In a nutshell, this allows the injector to inspect and update some specific object in the Kubernetes API.
It will automatically inject the Envoy sidecar proxy into every pod which has the required annotations.

## Types

Istio stores all it's configuration directly in the Kubernetes API through the use of Custom Resource Definitions (CRDs).
Next, a small description of the ones relevant for our blog are explained.

### Policies

[Policies](https://istio.io/docs/concepts/security/#authentication-policies) are at the heart of the mTLS setup in Istio.
They define when mTLS should be used and how.
Policies can be scoped in two levels: mesh wide (Mesh Policies) and namespace wide.

### Destination Rules

[Destination rules](https://istio.io/docs/concepts/traffic-management/#destination-rules) are a set of rules that are executed when a services is called.
They define multiple different routing options.
For the scope of this blogpost, they will only be used to define which services require to be access using mTLS.

### Service Roles

[Service Roles](https://istio.io/docs/concepts/security/#servicerole) are used in Istio to describe which access a role provides. 
It specifies which endpoints can be used of a specific service. 
Currently this is described by specifying the full internal DNS name of the service and the methods that the role can access.

### Service Role Bindings

[Service Role Bindings](https://istio.io/docs/concepts/security/#servicerole) are used to connect identities (service accounts) or identity properties (namespaces) to actual roles. 
When binding is created, the identities connect to it are allowed the access specified in the reference service role.

## Why do I need RBAC for internal services?

Applications needs to be secured. 
When a user want to access a service, they have to provide login credentials ( username and password, a token, a session cookie,... ). 
Based on the authentication information the service receives from the user, it determines the access the user has in the application.
These two mechamismes called Authentication (Who are you) and Authorization (What can you access) have existed in applications for a long time. 

Not only user level access needs to be secured.
Services need to be able to connect to eachother as well.
Securing access between services can be achieved the same way as for users, by authenticating with a username and password, by fetching a token, etc.
When the application only contains a handful of services, managing this is easy. 
When an application has multiple replicas of these services or when they are part of a platform, managing the secrets and access becomes a bigger challenge.
In a microservice world, services can easily have thousands of instances.
Managing every single instance, let alone providing individual credentials is not feasible.

* Good authorization is defined on 4 levels (find link!)
   * Who can access an endpoint
   * Who can do what action on the endpoint
   * Who can access a given resource
   * What data can they access for that resource
* Defence in depth
   * Least privileged access
   * Attacker in network -> still no real access
* Discover misconfiguration easily

## How does this work in Istio?

* Authentication -> mTLS -> citadel?
* Authorization -> proxy policies -> mixer
* -Service Role-
* -Service Role Binding-

When using the Istio service mesh, all traffic is routed throught the service mesh. 
This allows the Envoy proxy to inspect the traffic.


There are two main features that we want to enable in the cluster: Service Authentication and Service Authorization.
Service Authentication is provided by Kubernetes through a combination of the Kubernetes service account, Envoy and Istio Mutual TLS (mTLS). 
When a deployment is created in Kubernetes, it's always associated with a service account.
If no service account is specified, the default service account for the namespace is used.
In the Istio setup, it is preferred to create and assign a service account to each service in the cluster. 
When a connection is created between two service in the cluster, Istio authenticates the connection through a Mutual TLS. Since 

## What are ingress and egress?

* Ingress
   * Front end reverse proxy
   * Maps incoming requests to the proper 'backend'
* Egress
   * Gateway for contacting external services
   * Provides insight and control to what services are accessed
   * Provides the same level of control over accessing external services as internal services
   * Handle external services like internal once
   * Provide ingress style definition for external services

## How does Istio provide ingress and egress support?

* Envoy proxy
* Gateway object
   * ingress
   * egress
* Virtual service object
* Destination Rule object
* Service entry object

## Show me the code

* Show diagram of final setup of the demo ( 2 databases, 3 services ) 

Service 1 -> Database 1
Service 2 -> Database 2
Service 2 /-> Database 1
Service 3 -> External source
Service 3 /-> Service 1
Service 3 /-> Service 2

* How to setup Istio
   * 1.0.5 -> What to configure and how. (https://gitlab.com/pieter.vincken1/istio-authn-authz-demo) consider moving this to github
* How to enable mTLS (required to do RBAC)
* Deploy the demo services
* Show that access to the services (diagram!)
* Create service roles
   * Explain how they work -> they define what access the role provides
* Create service role binding
   * How to connect the roles to a service account
   * A service account can have multiple roles
* Apply the roles and bindings to the setup
* Show that the access changed. 

* Enable ingress objects
   * Create an ingress gateway
   * Create virtual services for the services (2)
* Enable egress support

## Usefull links 
* https://istio.io/docs/reference/config/authorization/istio.rbac.v1alpha1/
* https://istio.io/docs/examples/advanced-egress/egress-gateway/


### Conclusion

## Summing it all up 



