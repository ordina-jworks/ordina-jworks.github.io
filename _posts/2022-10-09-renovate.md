---
layout: post
authors: [pieter_vincken]
title: 'Keeping up with dependencies like a boss'
image: /img/20221009-renovate/logo.png
tags: [cloud, automation, cicd]
category: Cloud
comments: true
---

- [What's the problem?](#whats-the-problem)
- [What is Database Lab?](#what-is-database-lab)
- [End user interaction](#end-user-interaction)
- [Behind the curtains](#behind-the-curtains)
- [How to setup](#how-to-setup)
- [How to use it](#how-to-use-it)
- [More cool features](#more-cool-features)
- [Why should I use it?](#why-should-i-use-it)
- [Links](#links)

## What's the problem?

### Lack of features

Let's imagine you need to implement support for a new feature.
Let's imagine that that feature is super easy to implement due to almost native support for the functionality in a library you're already using. 
That sounds like a great day, right? 
You add the code to glue together the API to the library, perform some tests and call it a day. 
There is just one problem, you didn't check which version of the dependency you were using and the feature you need is only supported in versions 8.x.x and beyond. 
You check your `pom.xml`, only to figure out that you're on version `6.8.21`.
Now you have two options, refactor 25% of your codebase to be able to use the new library or 5x your effort for implementing the feature without the support of the library.
That doesn't sound like a great day at the (home-)office, now does it?

Wouldn't be great to have been on version `8.1.2` already?

<!-- ### Dependent systems

Let's imagine another scenario.
You're a platform engineer in a large company. 
Among other things, you're responsible for operating the Apache Kafka clusters used by your company. 
You have 20 different teams using various Kafka clusters across different environments.
You get a request from one of the teams to update the Kafka cluster to a more recent version.
Since teams share the Kafka clusters for certain environments, you need to make sure all of them have supported versions of the clients.
Now, you have a couple of options: tell the requesting team no, tell all teams to upgrade to a supported version of the client libraries or upgrade all components yourself to a supported client library.  

//TODO
// Dependent systems updated -> libary support missing for newer version
// Dependent systems outdated -> unable to update libary due to outdated version

-->

### Security Vulnerability

Now we get to a scenario that maybe 50% of the Java community experienced at the end of 2021.
A severe security vulnerability was discovered in a very popular logging library: Log4J. 
Normally, vulnerabilities aren't this severe and there aren't part of the nine o'clock news.
Now imagine that you are using a vulnerable software component and you aren't informed by the news that you need to urgently update, how would you know about the vulnerability? 
Maybe you have some scanning software that checks for know CVEs?
Maybe you have really good developers that are subscribed to the mailing lists of all dependencies they're using?
Or more likely than not, you just don't know you're vulnerable. 
OWASP identified `Vulnerable and outdated components` as number six on their `Top 10 Web Application Security Risks` of 2021.

Wouldn't it have been nice to have a PR on every repository that had the Log4J dependency with the new version updated? So that you only had to merge that PR to mitigate the vulnerability?


## What is Mend Renovate?

Mend Renovate (formerly known as WhiteSource Renovate) is a tool that detects dependencies in your code and informs you if there are new versions of your dependencies available.
It's a free tool that can be used as a Github App or as a self-hosted tool. 
Renovate scans a repository and detects the used dependencies, relying on dependency managers. 
As of time of writing, Renovate supports about [80 different dependency management](https://docs.renovatebot.com/modules/manager/){:target="_blank" rel="noopener noreferrer"} systems out of the box.
Next, it can integrate with your code repositories (e.g. Bitbucket, Github, Gitlab, ...) and automatically update the dependency in your code and create pull requests for every update it detects.
It can even detect changelogs (if available) and add the changelog information to the PR. 
This is especially helpful if there are (manual) changes required to use the new version of the dependency.
So Renovate can `detect` your dependencies, `inform` you about the updates and even tell you `how` to update.

## Behind the curtains

Now, how does this magic work? 

Renovate starts by scanning your source code for dependencies.
It does this by looking for dependency files in your environment, let's take the example file structure below as an example.

```bash
repo/ 
├─ src/ 
├─ Dockerfile 
├─ pom.xml
```

Renovate will detect a Dockerfile and a Maven dependency file (`pom.xml`).
It will pass these files to the dependency managers internally and detect which dependencies are being used.
Let's imagine that the Dockerfile has the following from line at the top: `FROM amazoncorretto:18.0.0`
The dependency manager for docker will detect that this is the repository `amazoncorretto` with tag `18.0.0`. 
Next, it will look in the `pom.xml`. 

Excerpt of the pom.xml:
```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>2.12.2</version>
</dependency>
```
**Note: Never use this dependency! This is a vulnerable version of log4j-core.**

Renovate will detect the following Maven dependency: `org.apache.logging.log4j:log4j-core:2.12.2`

Now that if 

## How to setup

## How to use it


## More cool features

## Why should I use it?

If you're in a project where access to production systems is not available and/or testing migration scenarios is very time consuming, this might be a good tool for you to investigate, provided of course that you're using PostgreSQL databases.
It provides an easy, scalable and safe way to provide copies of large databases without having to wait hours or days to copy over data from one database to the next to test something. 

Adding to that the possibility to obfuscate the data with the same tool and allow developers to work with obfuscated data during their developer, makes it an even more compelling choice.

The software is opensourced on [Gitlab](https://gitlab.com/postgres-ai){:target="_blank" rel="noopener noreferrer"} and the community on [Slack](https://slack.postgres.ai/){:target="_blank" rel="noopener noreferrer"} is very helpful and response if you have any questions or issues with the software.

If you want a more in-depth post about how to configure DLE and which pitfalls we found, let me know on [LinkedIn!](https://www.linkedin.com/in/pieter-vincken-a94b5153/){:target="_blank" rel="noopener noreferrer"}

### Links

- [Mend Renovate website](https://www.mend.io/free-developer-tools/renovate/){:target="_blank" rel="noopener noreferrer"}
- [Renovate Github Repository](https://github.com/renovatebot/renovate){:target="_blank" rel="noopener noreferrer"}
- [Renovate docs](https://docs.renovatebot.com/){:target="_blank" rel="noopener noreferrer"}
- [JOIN 2022 Talk YouTube Link](TODO){:target="_blank" rel="noopener noreferrer"}

Feel free to reach out to [me](https://www.linkedin.com/in/pieter-vincken-a94b5153/){:target="_blank" rel="noopener noreferrer"} if you want to look into this solution. 

Special thanks to the Unicorn team for helping with the blogpost and automating the dependency updates!